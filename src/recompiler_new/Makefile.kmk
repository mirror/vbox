# $Id$
## @file
# The Recompiler Sub-Makefile.
#
#
# Copyright (C) 2006-2007 Sun Microsystems, Inc.
#
# This file is part of VirtualBox Open Source Edition (OSE), as
# available from http://www.virtualbox.org. This file is free software;
# you can redistribute it and/or modify it under the terms of the GNU
# General Public License (GPL) as published by the Free Software
# Foundation, in version 2 as it comes in the "COPYING" file of the
# VirtualBox OSE distribution. VirtualBox OSE is distributed in the
# hope that it will be useful, but WITHOUT ANY WARRANTY of any kind.
#
# Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa
# Clara, CA 95054 USA or visit http://www.sun.com if you need
# additional information or have any questions.
#


SUB_DEPTH = ../..
include $(KBUILD_PATH)/subheader.kmk

#
# Globals
#
VBOX_PATH_RECOMPILER_SRC := $(PATH_SUB_CURRENT)

# For 32-bit targets when enabled 64-bit guests we build 2 REM DLLs:
#  with 64-bit support (slow and buggy at the moment) VBOXREM64
#  only 32-bit support (faster, stable, but not suitable for 64-bit guests) VBOXREM32
# During the runtime, we load appropriate library from VBOXREM, depending on guest settings.
# 64-bit targets have 64-bit enabled REM by default, so is not part of this mess
ifeq ($(KBUILD_TARGET_ARCH),x86)
 ifdef VBOX_WITH_64_BITS_GUESTS
   VBOX_USE_REM64 := 1
 endif
endif


TEMPLATE_DUMMY = dummy template (move to kBuild) ## @todo Will be there in the next update, remove this.

if 0
 #
 # Template useful for forcing a specific gcc version in case it comes in handy.
 #
 TOOL_MYGCC = description
 TOOL_MYGCC_EXTENDS = GCC3
 TOOL_MYGCC_CC = $(firstword $(which gcc-4.2 gcc-4.1 gcc-3.4 gcc-3.4.6 gcc-3.3 gcc-3.3.6  gcc-3.2))
 TOOL_MYGCC_COMPILE_C_DEPEND =
 TOOL_MYGCC_COMPILE_C_DEPORD =
 TOOL_MYGCC_COMPILE_C_OUTPUT =
 define TOOL_MYGCC_COMPILE_C_CMDS
	$(QUIET)$(TOOL_MYGCC_CC) -c\
		$(flags) $(addprefix -I, $(incs)) $(addprefix -D, $(defs))\
		-Wp,-MD,$(dep) -Wp,-MT,$(obj) -Wp,-MP\
		-o $(obj)\
		$(abspath $(source))
 endef
 #Usage: target-i386/op_helper.c_TOOL = MYGCC
endif

## @todo Note to self (bird): Convert this mess to use NAME (that property didn't exist when the REM_MOD hack was first made I think).

# For 64-bit Windows we currently use gcc (due to MSVC unaware of such a novel
# thing as C99, a lot of GCC extensions deployed by QEMU and calling convention
# differences) to cross-compile code to Linux/ELF and dynamically generate invocation wrappers.
if1of ($(KBUILD_TARGET).$(KBUILD_TARGET_ARCH), win.amd64)
 VBOX_USE_REM2 = 1
 REM_MOD := VBoxREM2
else
 REM_MOD := VBoxREM
endif

#
# Target lists (some of them anyways).
#
ifdef VBOX_USE_REM2
 SYSMODS += VBoxREM2
else
 ifndef VBOX_USE_REM64
  DLLS    += VBoxREM
 endif
endif


#
# The VBoxREM.[dll|so|..] or VBoxREM2.rel.
#
ifeq ($(KBUILD_TARGET),win)
$(REM_MOD)_TEMPLATE        = DUMMY
$(REM_MOD)_TOOL.win.x86    = MINGW32
$(REM_MOD)_TOOL.win.amd64  = XGCCAMD64LINUX
$(REM_MOD)_SDKS.win.x86    = W32API
$(REM_MOD)_ASFLAGS         = -x assembler-with-cpp
$(REM_MOD)_CFLAGS          = -Wall -g -fno-omit-frame-pointer -fno-strict-aliasing
$(REM_MOD)_CFLAGS.debug    = -O0
$(REM_MOD)_CFLAGS.release += -fno-gcse -O2
$(REM_MOD)_CFLAGS.profile  = $($(REM_MOD)_CFLAGS.release)
$(REM_MOD)_DEFS           += IN_RING3 $(ARCH_BITS_DEFS)
# workaround the regparm bug in gcc <= 3.3
$(REM_MOD)_DEFS.win.x86   += GCC_WITH_BUGGY_REGPARM
else  # !win
$(REM_MOD)_TEMPLATE        = VBOXR3NP
# workaround the regparm bug in gcc <= 3.3
$(REM_MOD)_DEFS            = $(if $(VBOX_GCC_BUGGY_REGPARM),GCC_WITH_BUGGY_REGPARM,)
endif # !win
$(REM_MOD)_DEFS           += IN_REM_R3 REM_INCLUDE_CPU_H
#$(REM_MOD)_DEFS           += REM_PHYS_ADDR_IN_TLB
$(REM_MOD)_DEFS           += VBOX_WITH_NEW_RECOMPILER
#$(REM_MOD)_DEFS           += DEBUG_ALL_LOGGING DEBUG_DISAS DEBUG_PCALL DEBUG_EXEC DEBUG_FLUSH DEBUG_IOPORT DEBUG_SIGNAL DEBUG_TLB_CHECK DEBUG_TB_INVALIDATE DEBUG_TLB  # Enables huge amounts of debug logging.
#$(REM_MOD)_DEFS           += DEBUG_TMP_LOGGING # log qemu parts to "/tmp/vbox-qemu.log" - does not work with VBoxREM2.
$(REM_MOD)_DEFS.linux      = _GNU_SOURCE
ifdef VBOX_SOLARIS_10
 $(REM_MOD)_DEFS.solaris   = HOST_SOLARIS=10
else
 $(REM_MOD)_DEFS.solaris   = HOST_SOLARIS=11
endif

$(REM_MOD)_INCS            = 		\
	Sun 				\
	target-i386 			\
	tcg 				\
	fpu 				\
	$(PATH_$(REM_MOD)) 		\
	$(PATH_ROOT)/src/VBox/VMM 	\
	.
ifn1of ($($(REM_MOD)_DEFS),DEBUG_TMP_LOGGING)
$(REM_MOD)_DEFS           += LOG_USE_C99
$(REM_MOD)_INCS           <= \
	Sun/crt
endif

$(REM_MOD)_SOURCES         = 		\
	VBoxRecompiler.c 		\
	cpu-exec.c	 		\
	exec.c 				\
	translate-all.c 		\
	host-utils.c 			\
	cutils.c 			\
	tcg/tcg.c 			\
	tcg/tcg-dyngen.c 		\
	tcg/tcg-runtime.c 		\
	fpu/softfloat-native.c 		\
	target-i386/op_helper.c 	\
	target-i386/helper.c 		\
	target-i386/translate.c

ifeq ($(KBUILD_TARGET_ARCH),amd64)
 $(REM_MOD)_DEFS          += __x86_64__
 $(REM_MOD)_INCS          +=  tcg/x86_64
else
 $(REM_MOD)_DEFS          += __i386__
 $(REM_MOD)_INCS          +=  tcg/i386
endif

$(REM_MOD)_SOURCES.debug  += \
	Sun/testmath.c
$(REM_MOD)_SOURCES.win.x86 = $(PATH_VBoxREMImp)/VBoxREMWin.def
ifndef VBOX_USE_REM2
 $(REM_MOD)_POST_CMDS      = $(VBOX_SIGN_IMAGE_CMDS)
endif
ifdef VBOX_USE_REM2
## @todo spread out where it belongs.
$(REM_MOD)_TEMPLATE        = VBOXNOCRTGAS
$(REM_MOD)_DEFS           += LOG_USE_C99 $(ARCH_BITS_DEFS)

# This doesn't fit in IPRT because it requires GAS and is LGPL.
$(REM_MOD)_SOURCES        += \
	Sun/e_powl-$(KBUILD_TARGET_ARCH).S

$(REM_MOD)_INCS           += \
        Sun/crt
$(REM_MOD)_SYSSUFF         = .rel
endif
ifdef VBOX_USE_REM2
$(REM_MOD)_LIBS            = \
	$(PATH_LIB)/RuntimeR3NoCRTGCC$(VBOX_SUFF_LIB)
else
$(REM_MOD)_LIBS            = \
	$(LIB_VMM) \
	$(LIB_RUNTIME)
$(REM_MOD)_LIBS.darwin     = \
	$(TARGET_VBoxREMImp)
endif

## @todo clean up this, there are some duplicates with the template here I think.
$(REM_MOD)_LDFLAGS.darwin  = -install_name $(VBOX_DYLD_EXECUTABLE_PATH)/$(REM_MOD).dylib
$(REM_MOD)_LDFLAGS.l4      = -T$(L4_LIBDIR)/../main_rel.ld -nostdlib -Wl,--no-undefined
$(REM_MOD)_LDFLAGS.linux   = $(VBOX_LD_as_needed)
$(REM_MOD)_LDFLAGS.os2     = -Zomf
$(REM_MOD)_LDFLAGS.debug   = -g
$(REM_MOD)_LDFLAGS.solaris = -mimpure-text


if defined(VBOX_USE_REM2) || defined(VBOX_USE_REM64)
#
# The VBoxREM2 wrapper.
#
DLLS += VBoxREMWrapper
VBoxREMWrapper_TEMPLATE    = VBOXR3
VBoxREMWrapper_NAME        = VBoxREM
VBoxREMWrapper_DEFS        = IN_REM_R3 $(if $(VBOX_WITH_VMI),VBOX_WITH_VMI,)
VBoxREMWrapper_DEFS       += VBOX_WITH_NEW_RECOMPILER
 ifdef VBOX_USE_REM64
VBoxREMWrapper_DEFS       += VBOX_USE_BITNESS_SELECTOR
 endif
VBoxREMWrapper_SOURCES     = \
	VBoxREMWrapper.cpp \
	$(if $(VBOX_USE_REM2),VBoxREMWrapperA.asm)
VBoxREMWrapper_LIBS        = \
	$(LIB_VMM) \
	$(LIB_RUNTIME)
VBoxREMWrapper_LIBS.darwin += \
	$(TARGET_VBoxREMImp)
#VBoxREMWrapper_LDFLAGS.darwin = -install_name $(VBOX_DYLD_EXECUTABLE_PATH)/VBoxREM.dylib
endif


ifdef VBOX_USE_REM64
 DLLS += VBoxREM32
 VBoxREM32_EXTENDS    = VBoxREM
 VBoxREM32_EXTENDS_BY = appending
 VBoxREM32_TEMPLATE   = $(VBoxREM_TEMPLATE)
 VBoxREM32_LDFLAGS.darwin = -install_name $(VBOX_DYLD_EXECUTABLE_PATH)/VBoxREM32.dylib
 VBoxREM32_LIBS.darwin = $(LIB_REM)

 DLLS += VBoxREM64
 VBoxREM64_EXTENDS    = VBoxREM
 VBoxREM64_EXTENDS_BY = appending
 VBoxREM64_TEMPLATE   = $(VBoxREM_TEMPLATE)
 VBoxREM64_DEFS       = VBOX_ENABLE_VBOXREM64
 VBoxREM64_LDFLAGS.darwin = -install_name $(VBOX_DYLD_EXECUTABLE_PATH)/VBoxREM64.dylib
 VBoxREM64_LIBS.darwin = $(LIB_REM)

endif # USE_VBOXREM64


#
# The VBoxREM import library.
#
# This is a HACK to get around (a) the cyclic dependency between VBoxVMM and
# VBoxREM during linking and (b) the recursive build ordering which means VBoxREM
# won't be built until after all the other DLLs.
#
IMPORT_LIBS += VBoxREMImp
VBoxREMImp_TEMPLATE        = VBOXR3
 ifn1of ($(KBUILD_TARGET), os2 win)
VBoxREMImp_NAME            = VBoxREM
 endif
VBoxREMImp_INST            = $(INST_LIB)
VBoxREMImp_SOURCES.win     = $(PATH_VBoxREMImp)/VBoxREMWin.def
VBoxREMImp_SOURCES.os2     = $(PATH_VBoxREMImp)/VBoxREMOS2.def
 ifn1of ($(KBUILD_TARGET), os2 win)
VBoxREMImp_SOURCES         = $(PATH_VBoxREMImp)/VBoxREMImp.c
VBoxREMImp_CLEAN           = $(PATH_VBoxREMImp)/VBoxREMImp.c
 endif
 ifn1of ($(KBUILD_TARGET), darwin os2 win)
VBoxREMImp_SONAME          = VBoxREM$(SUFF_DLL)
 endif
VBoxREMImp_LDFLAGS.darwin   = -install_name $(VBOX_DYLD_EXECUTABLE_PATH)/VBoxREM.dylib
VBoxREMImp_LDFLAGS.l4       = -T$(L4_LIBDIR)/../main_rel.ld -nostdlib

$$(PATH_VBoxREMImp)/VBoxREMImp.c: $(VBOX_PATH_RECOMPILER_SRC)/VBoxREM.def $(VBOX_PATH_RECOMPILER_SRC)/Sun/deftoimp.sed $(MAKEFILE_CURRENT) | $$(dir $$@)
	$(call MSG_GENERATE,,$@)
	$(QUIET)$(APPEND) -t $@ '#ifdef VBOX_HAVE_VISIBILITY_HIDDEN'
	$(QUIET)$(APPEND)    $@ '# define EXPORT __attribute__((visibility("default")))'
	$(QUIET)$(APPEND)    $@ '#else'
	$(QUIET)$(APPEND)    $@ '# define EXPORT'
	$(QUIET)$(APPEND)    $@ '#endif'
	$(QUIET)$(APPEND)    $@ ''
	$(QUIET)$(SED) -f $(VBOX_PATH_RECOMPILER_SRC)/Sun/deftoimp.sed --append $@ $<

$$(PATH_VBoxREMImp)/VBoxREMOS2.def: $(VBOX_PATH_RECOMPILER_SRC)/VBoxREM.def $(MAKEFILE_CURRENT) | $$(dir $$@)
	$(SED) \
		-e 's/^[ \t][ \t]*REMR3/    _REMR3/' \
		-e 's/\.[Dd][Ll][Ll]//' \
		-e 's/^LIBRARY .*/LIBRARY VBoxREM INITINSTANCE TERMINSTANCE\nDATA MULTIPLE\n/' \
		--output $@ \
		$<

$$(PATH_VBoxREMImp)/VBoxREMWin.def: $(VBOX_PATH_RECOMPILER_SRC)/VBoxREM.def $(MAKEFILE_CURRENT) | $$(dir $$@)
ifdef VBOX_WITH_NEW_PHYS_CODE
	$(SED) -e '/REMR3NotifyPhysRamChunkRegister/d'	--output $@ $<
else
	$(CP) -f $< $@
endif


#
# The math testcase as a standalone program for testing and debugging purposes.
#
## @todo This is a bit messy because of MINGW32.
testmath_ASFLAGS.amd64  = -m amd64
testmath_CFLAGS         = -Wall -g
testmath_CFLAGS.release = -O3
testmath_LDFLAGS        = -g
testmath_DEFS           = MATHTEST_STANDALONE
testmath_DEFS          += VBOX_WITH_NEW_RECOMPILER
testmath_SOURCES        = Sun/testmath.c


include $(KBUILD_PATH)/subfooter.kmk
